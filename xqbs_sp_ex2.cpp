/*
* This software is copyright protected (C) 2009 XQBS
*
* Author:                Alexey N. Zhirov
* E-mail:                src@xqbs.ru
* Module:                xqbs_sp_ex2.cpp
*
*/

// Работа с Win32 API
#include <windows.h>
// Работа со строками
#include <string>
// Работа со списком
#include <list>
// Счетчик ссылок
#include "xqbs_refbase.h"

// Зачем нужна эта функция? Эта функция всегда, независимо от настроек компилятора,
// генерирует исключение std::bad_alloc всякий раз, когда есть проблемы с выделением памяти.
template <class T> T* XQBS_New(void)
{
    // Создаем объект T
    T* pObj = new T;

    // Если объект не создался
    if (!pObj)
    {
        // Генерируем исключение
        throw std::bad_alloc();
    }

    // Возвращаем указатель
    return pObj;
}

// Для однотипных операций имеет смысл сделать шаблонную функцию
template<class T> void IfRelease(T*& ptr)
{
    // Если указатель валидный
    if (ptr)
    {
        // Скидываем свою ссылку
        ptr->Release();
        // После удаления своей ссылки, обязательно зануляем указатель,
        // т.к. данный объект больше нам не пренадлежит.
        ptr = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
// Этот SmartPointer позволяет хранить один объект использующий счетчик ссылок
template<class T>
class XQBS_SmartPtr
{
    // Указатель на контролируемый объект
    volatile T* m_ptr;

public:

    // Конструктор по умолчанию
    XQBS_SmartPtr(T* ptr = NULL) : m_ptr(NULL)
    {
        // Если надо создать SmartPointer от указателя
        operator= (ptr);
    }

    // Конструктор копирования
    XQBS_SmartPtr(const XQBS_SmartPtr& rhs) : m_ptr(NULL)
    {
        // Используем оператор присваивания
        operator= (rhs);
    }

    // Деструктор
    virtual ~XQBS_SmartPtr()
    {
        // Скидываем свою ссылку
        IfRelease(m_ptr);
    }

    // Перегрузка оператора присваивания для самого SmartPointer-а
    inline XQBS_SmartPtr& operator= (const XQBS_SmartPtr& rhs)
    {
        // Проверка на присваивания себя себе
        if (this == &rhs)
            // Пользователь данного класса хочет странного, выходим!
            return *this;

        // Вызываем уже реализованный метод для присваивания указателя
        return operator= (rhs.m_ptr);
    }

    // Перегрузка оператора присваивания для указателя типа T
    inline XQBS_SmartPtr& operator= (T* ptr)
    {
        // Проверка для реальных объектов
        if (m_ptr == ptr)
            // Уже равны
            return *this;


        // Скидываем свою ссылку с текущего подконтрольного объекта
        IfRelease(m_ptr);

        // Если реальный объект, который нам надо взять под свой контроль существует
        if (ptr)
        {
            // Накидываем свою ссылку на него
            ptr->AddRef();
            // Сохраняем указатель на новый объект
            m_ptr = ptr;
        }

        // Собственно все! Объект реально копировать не надо, только ссылку на него
        // Такой метод присваивания я называю присваивание с нулевым копированием данных.
        return *this;
    }

    // Перегрузим оператор стрелочка для прозрачного доступа к реальному объекту
    inline T* operator-> ()
    {
        // Если объекта еще нет, создаем его
        if (!m_ptr)
        {
            // Создаем реальный объект (при создании, объект уже имеет одну ссылку, она наша)
            // Так как объект ссылочный, то он должен уметь сам себя создавать!
            m_ptr = T::CreateSelf();
        }

        // Возвращаем указатель на реальный объект
        return m_ptr;
    }

    // Перегрузим оператор разыменования для прозрачного доступа к реальному объекту
    inline T& operator* ()
    {
        // Для создания объекта используем уже реализованный метод
        return *operator->();
    }
};


///////////////////////////////////////////////////////////////////////////////
// Пример работы с счетчиком ссылок.
class XQBS_TempObj : public _XQBS XQBS_RefBase
{
    // Для пример возьмем строку
    std::string m_str;

protected:

    // Деструктор
    virtual ~XQBS_TempObj()
    {
    }

public:

    // Конструктор
    XQBS_TempObj()
    {
    }

    // Создать себя
    static XQBS_TempObj* CreateSelf(void)
    {
        return XQBS_New<XQBS_TempObj>();
    }

    // Полный доступ к строке
    std::string& str(void)
    {
        return m_str;
    }
};

// Объявим список SmartPointer-ов для хранения указателей в списке
typedef std::list< XQBS_SmartPtr<XQBS_TempObj> > lst_t;

// Точка входа
int main(void)
{
    // Описываем SmartPointer1 для динамического контроля
    XQBS_SmartPtr<XQBS_TempObj> SmartPtr1;

    try
    {
        // Инициализируем строку
        (*SmartPtr1).str().assign("Hello world!");

        // Для проверки удаления ссылок, второй SmartPointer опишем в
        // локальной области видимости.
        {
            // Описываем SmartPointer2 для динамического контроля
            XQBS_SmartPtr<XQBS_TempObj> SmartPtr2;

            // Проверим оператор присваивания
            SmartPtr2 = SmartPtr1;

            // Присваиваем второму объекту новую строку
            (*SmartPtr2).str().assign("New world!");
        }

        // Распечатываем строку первого объекта в консоль
        printf("%s ", (*SmartPtr1).str().c_str());

            // Создадим новый объект
            XQBS_TempObj* pTempObj = XQBS_TempObj::CreateSelf();

        // Присваиваем строку
        pTempObj->str().assign("Test refcount mechanism");

        // Отдадим наш указатель в надежные руки
        SmartPtr1 = pTempObj;

        // Свою ссылку надо снять (заRelease-ить)
        IfRelease(pTempObj);

        // Распечатываем строку первого объекта в консоль
        printf("%s ", (*SmartPtr1).str().c_str());

        // Список указателей, которые всегда удаляются!
        lst_t lst;

        // Цикл для проверки теории на практике
        for(int i = 0; i < 10; ++i)
        {
            // Создаем объект и получаем указатель на него
            pTempObj = XQBS_TempObj::CreateSelf();

            // Запихиваем указатель в список.
            // Опытный программист знает, что в этом простом действии есть один подвох,
            // а именно: lst объявлен как список объектов типа XQBS_SmartPtr<XQBS_TempObj>,
            // а мы в него пихаем XQBS_TempObj* таким образом на стеке неявно всегда
            // создается временный объект XQBS_SmartPtr<XQBS_TempObj>, который уничтожается
            // после выполнении операции копирования.
            // Если бы не счетчик ссылок, то в этой строке произошло бы два создания,
            // два копирования и одно удаление объекта, а так нет, копируются только ссылки!!!
            lst.push_back( pTempObj );

            // Если все прошло успешно, то скидываем свою ссылку.
            IfRelease( pTempObj );

            // Всё, теперь единственный владелец этого и других указателей - это список.
            // Когда список начнет разваливаться, все объекты будут удалены автоматически,
            // можно о них забыть и не боятся ни исключений, ни утечек памяти!!!
        }
    }
    catch (std::bad_alloc& e) // Перехватываем исключение std::bad_alloс
    {
        // Распечатываем строку исключения
        printf("%s", e.what());
    }

    // Все ОК
    return 0;
}
